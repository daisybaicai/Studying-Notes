### 1.在浏览器输入URL后HTTP请求的完整过程

这一部分仅仅为HTTP为重点来进行描述，对于相关请求响应后的例如CSS，JS渲染页面等就不做阐述。

![image](https://img-blog.csdnimg.cn/20190321211354443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDIxNTU0,size_16,color_FFFFFF,t_70)

这是我在网上看到的一张图，这里将上述问题都进行了大致的描述。

然后我们再来看上面那张图，

(1)一开始发起请求url，一开始就redirect的原因是，可能浏览器已经记录你的地址跳转一个新的地址，浏览器需要判断需要不需要redirect。（就比如说你之前这个网站都是通过a.test.com来访问的现在换域名了变成b.test.com了要进行redirect）

(2)再去看缓存里面有没有，如果有就返回

(3)如果没有就要去实际的域名里面找，输入的是域名，找到需要对应成实际的IP才行，也就是DNS解析。

(4)有了IP以后，就要创建TCP连接，需要三次握手以后才能创建链接，如果是HTTPS，就是创建HTTPS的链接和HTTP三次握手不一样，要有一一个安全的过程。

(5)连接好了以后才发请求，发送请求的数据好了以后，

(6)服务器接受并返回请求的相应的数据。

### 2.五层模型
 

![image](https://img-blog.csdnimg.cn/20190321211804718.png)

经典的五层模型，其中下面三层，物理层主要是定义物理设备以及如何传输数据，数据链路层是在通信实体间建立数据链路连接，网络层为数据在结点之间传输创建逻辑链路。

传输层，为用户提供了可靠的端到端的服务，向高层屏蔽了下层数据通信的细节。（TCP,UDP）

应用层，为应用软件提供了很多服务，构建在TCP协议之上，屏蔽了网络传输的相关细节。（HTTP,FTP..）

### 3.HTTP 0.9，HTTP1.0，HTTP1.1，HTTP 2.0
HTTP 0.9

  是最早的，它只有一个命令就是get,没有header等描述信息，在服务器发送完毕后，就会关闭TCP连接。

HTTP1.0

  它增加了很多命令，增加了status,code,和header,可以多字符集支持，多部分发送，权限，缓存等。

HTTP1.1

  它有了持久连接，pipeline,增加了host和其他的一些命令。

  持久连接：http持久连接，就是在一个http请求要发送的话，客户端和服务端之间要建立三次握手，然后在客户端和服务端建立连接完毕以后，在服务端返回完内容以后就关闭掉了这个TCP连接，代价比较大。持久连接就是发送完以后，可以不关闭这个TCP连接了，就会减少这个代价。

 pipeline:在同一个连接中发送多个请求。服务端按顺序内容返回。串行。

HTTP 2.0

  所有的数据以二进制传输，同一个连接的多个请求不需要再按照顺序来进行，可以并行，头信息压缩以及推送等提高效率的功能。

  在http1头信息都要完整的发送，通过字符串保存，占用的带宽大。

  推送：之前只能是客户端主动发送请求，服务端被动接受请求，现在服务端可以主动的发送了，也就是推送。

  顺序：不再是串行，而是可以并行，请求HTML的同时可以把里面的js,css进行推送。

### 4.HTTP三次握手
在用户和浏览器交换资源的时候是只有请求和响应。而他们之间有一个传送通道，就是那个连接。可以一直保持。

http请求是在那个连接上进行发送的。

TCP连接是在这个之上发送的，

在TCP连接上面，一个HTTP可以发送多个请求。

在http1.0时候，

  在HTTP请求创建的时候，就去创建TCP连接，然后这个连接创建完以后，把请求发送过去，然后服务器响应了以后这个TCP连接就关闭了。

在http1.1的时候，

  这个连接我们可以通过某个方式去声明，连接就可以保持在那边。也就是说第一个请求发送完了，那个连接创建了保持在那边，然后第二个请求进来以后，就可以在这个连接上进行一个发送。tcp连接是需要三次握手的，三次握手是需要每次发送请求然后再响应的。这个代价是很大的，就是建立连接。

在http2.0中

  tcp连接上的http请求是可以并发的。

  就是说我们在同一个用户对同一个服务器发起一个网页请求的时候，只需要一个TCP连接。

三次握手的时序图。

![image](https://img-blog.csdnimg.cn/2019032121342976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDIxNTU0,size_16,color_FFFFFF,t_70)
标志位syn seq数字x一般是1

 

（1）首先客户端发送一个我要创建数据包的请求，他发送到服务端，里面有一个标志位，syn=1，还有一个seq他等于一个数字，一般来说也等于1.

（2）然后服务端接受到了这个数据包，知道有一个客户，他要和我进行连接了，如何进行连接，就会开启一个tcp的socket的端口，这个端口开启以后，返回给客户端一个数据包，里面有一个syn就是标志位，还有一个ack,ack就是第一个客户端发送过来的seq的x+1,还有服务端发送一个seq,这个是服务端的seq

（3）然后客户端拿到这个数据包以后，知道服务端允许我创建这个TCP链接了，然后他再发送他的ack等于seq+1，他的seq又等于一个新的数字。

 

#### 为什么要三次握手？
  三次握手，为了防止服务器，这边开始一些无用的连接，网络有延时，中间可能隔的很远，需要一个光纤，然后各种中间的代理服务器进行一个传输。

  在第二次握手的时候，服务端直接就创建了链接，然后返回了内容给客户端，因为网络传送，数据包丢手，客户端就一直没有接收到服务器返回的东西。

  同时，可能设置了一个超时时间，关闭了，连接关闭了才发起一个新的创建连接的请求，服务端不知道，如果没有三次握手，服务端根本不知道客户端有没有接收到，也没有告诉我要创建还是关闭，端口就一直开着，一直等着客户端发送实际的请求，此时服务端开销就浪费了，他不知道连接建立失败，可能客户端已经去发送新的连接了。所以需要三次握手来确认，来及时发现一些网络问题导致的丢包。

  同时端口的连接关闭了也不需要一直等着，三次握手就可以规避网络传输中的延时，导致的一些服务器开销的问题。

 

抓包工具:wireshark
  可以通过它很清楚的看到三次握手的过程。

### 5.URI,URN,URL
URI：uniform resource identifuer/统一资源标志符。

  用来唯一标识互联网上的信息资源，包括URL和urn。

URL：uniform resource location/统一资源定位器。
http://host.com:80/path?query=string#hash

有IP，端口，路由，以及传参，hash,

hash一般前端会作为锚点定位。

URN：永久统一资源定位符，在资源移动之后还能被找到。

 

### 6.HTTP报文格式
从几个简单的部分来看，他分为三个部分，首行，头部，以及内容。
![image](https://img-blog.csdnimg.cn/20190321214459132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDIxNTU0,size_16,color_FFFFFF,t_70)

首行可以看到有url,他的方法method（一般作为资源的操作，语义化的描述），以及状态码（定义服务器对请求的处理结果，各个区间的code有各自的语义），address,policy.头部的比较多，可以看下图。



### 7.通过node搭建一个简单的服务

```
const http = require('http')
 
http.createServer(function(request, response) {
    console.log('request come', request.url);
 
    response.end('123')
}).listen(8888)
```
