**1.从原型到原型链**

  1.隐式原型_proto_总是指向显示原生prototype
  2.函数才有prototype,每个对象都有一个_proto_属性。
  3.原型链依赖_proto_这个指针，每一级的原型对象都依靠这个指针指向上一级原型对象。
  4.原型链的尽头始终是null
  5.每个原型对象都有constructor指向构造函数
  6.原生对象充当两面派，既是构造函数也是对象
  原型链图：
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019032819254677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDIxNTU0,size_16,color_FFFFFF,t_70)

**2.词法作用域，动态作用域**

1.和大多数现代化编译语言一样，JS采用的是词法作用域。函数的作用域在函数定义时就绝决定了。
2.而动态作用域贼是，函数的作用域由函数调用时候才决定，比较典型的例子是github的bash.
3.作用域：程序代码定义变量的区域
4.作用域规定了如何查找变量，执行代码时对变量的访问权限。

**3.执行上下文栈**

1.JS引擎并非一行行分析和执行程序，而是一段段分析执行。当执行一段代码的时候，会进行一个准备工作。
2.函数执行时会做准备工作，就是会有执行上下文。
3.三种可执行代码：全局代码，函数代码，eval代码。
4.JS引擎创建了执行上下文栈来管理执行上下文。
5.函数提升，同名会被后者覆盖，实际上只会执行第二次声明的函数，执行上下文也只会创建第二次声明的执行上下文。

**4.变量对象**

1.执行上下文分为两个阶段：分析和执行
2.变量对象包括三个：形参，函数声明，变量声明。
3.函数声明，如果有变量相同的就替换这个属性。
4.变量声明，如果有和已经声明的形参或函数相同，变量就不干扰已经存在的属性。
5.执行上下文三属性：变量对象，this，作用域链。
6.全局对象，预定义的对象，全局函数和全局属性的占位符。全局对象，作用域链的头。
7.活动对象，函数进入执行上下文才被创建，通过arguments属性属性创建。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328193614878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDIxNTU0,size_16,color_FFFFFF,t_70)

总结几条：
1.全局上下文变量对象初始化全局对象。
2.函数上下文变量对象初始化只包括Arguments对象
3.进入执行上下文时添加相关的函数声明，形参，变量声明。
4.代码执行阶段会再次修改赋值。

未进入执行阶段之前，VO属性都不能被访问，进入执行阶段后，VO转化为AO，都能被访问，然后开始执行。但其实AO=VO+function parameters,arguments.
被激活VO之外，还有传入了参数和arguments这个特殊对象
